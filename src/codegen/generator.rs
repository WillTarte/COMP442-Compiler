#![allow(dead_code)]
use crate::codegen::allocator::{LabelAllocator, RegisterAllocator};
use crate::codegen::generator::ExprParseStorage::*;
use crate::codegen::instruction_set::Instruction::{
    Add, AddImmediate, And, BranchIfZeroLabel, Divide, Entry, Equal, Greater, GreaterEqual, Halt,
    JumpLabel, JumpLinkLabel, JumpRegister, Less, LessEqual, LoadWordLabel, Multiply, NoOp,
    NotEqual, Or, Res, StoreWordLabel, Substract, SubstractImmediate,
};
use crate::codegen::instruction_set::Register::*;
use crate::codegen::instruction_set::{Instruction, TaggedInstruction};
use crate::codegen::utils::{
    generate_arith_expr_postfix, is_arith_operand, is_arith_operator, sizeof,
};
use crate::lexer::token::TokenType;
use crate::parser::ast::{InternalNodeType, Node, NodeVal};
use crate::semantics::symbol_table::{ClassEntry, FunctionEntry, Scope, SymbolTable, Type};
use std::fmt;
use std::fmt::{Display, Formatter};

/// The output of the code generator
#[derive(Default)]
pub struct CodeGenOutput(Vec<TaggedInstruction>);

impl CodeGenOutput {
    pub fn append(&mut self, mut other: CodeGenOutput) {
        self.0.append(&mut other.0)
    }
    pub fn push(&mut self, inst: TaggedInstruction) {
        self.0.push(inst);
    }
}

impl IntoIterator for CodeGenOutput {
    type Item = TaggedInstruction;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Display for CodeGenOutput {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        for inst in self.0.iter() {
            write!(f, "{}\n", inst.to_string())?;
        }
        Ok(())
    }
}

/// Holds the code generated by the Moon generator
#[derive(Default)]
struct CodeGenerator {
    output: CodeGenOutput,
    resources: CodeGenOutput,
    current_label: Option<String>,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            output: CodeGenOutput::default(),
            resources: CodeGenOutput::default(),
            current_label: None,
        }
    }

    /// Adds a new tagged resource
    pub fn add_tagged_resource(&mut self, tag: &str, bytes: u32) {
        self.resources
            .0
            .push(TaggedInstruction(Some(tag.to_string()), Res(bytes)));
    }

    /// Adds a new instruction, consuming a tag if it is buffered
    pub fn add_instruction(&mut self, inst: Instruction) {
        if self.current_label.is_some() {
            let label = std::mem::replace(&mut self.current_label, None);
            self.output.0.push(TaggedInstruction(label, inst));
        } else {
            self.output.0.push(TaggedInstruction(None, inst));
        }
    }

    /// Adds a new tagged instruction
    pub fn add_tagged_instruction(&mut self, t_inst: TaggedInstruction) {
        if self.current_label.is_some() {
            log::warn!(
                "CURRENT LABEL {:?}; OTHER {:?}",
                self.current_label,
                t_inst.0
            );
            let old_label = std::mem::replace(&mut self.current_label, None);
            self.output.push(TaggedInstruction(old_label, NoOp));
        }
        self.output.0.push(t_inst);
    }

    /// Buffers a label for the next instruction
    pub fn buffer_label(&mut self, label: &str) {
        if self.current_label.is_some() {
            log::warn!("CURRENT LABEL {:?}; OTHER {}", self.current_label, label);
            let old_label = std::mem::replace(&mut self.current_label, None);
            self.output.push(TaggedInstruction(old_label, NoOp));
        }
        self.current_label = Some(label.to_string());
    }
}

/// The MOON code generator
pub struct MoonGenerator {
    label_allocator: LabelAllocator,
    register_allocator: RegisterAllocator,
    generator: CodeGenerator,
}

impl MoonGenerator {
    pub fn new() -> Self {
        Self {
            label_allocator: Default::default(),
            register_allocator: RegisterAllocator::new(),
            generator: Default::default(),
        }
    }

    /// Generates the MOON code given an AST and a symbol table
    pub fn generate(&mut self, ast: &Node, symbols: &SymbolTable) {
        self.visit_class_declarations(&ast.children()[0], symbols);
        self.visit_function_definitions(&ast.children()[1], symbols);
        self.visit_main_function(&ast.children()[2], symbols);

        self.generator.add_tagged_resource("fn_ptr_stack", 512);
    }

    /// Finishes the code generation. Returns the output.
    pub fn finish(mut self) -> CodeGenOutput {
        self.generator.output.append(self.generator.resources);
        self.generator.output
    }

    fn visit_class_declarations(&mut self, class_declarations: &Node, symbols: &SymbolTable) {
        for class_decl in class_declarations.children() {
            if let Some(NodeVal::Leaf(token)) = class_decl.children()[0].val() {
                if let Some(Scope::Class(ce)) = symbols.find_scope_by_ident(token.lexeme()) {
                    self.generate_class_code(ce, class_decl, symbols);
                }
            }
        }
    }

    fn generate_class_code(
        &mut self,
        _class_entry: &ClassEntry,
        _class_declaration: &Node,
        _symbols: &SymbolTable,
    ) {
        unimplemented!("Code generation for classes is not implemented");
    }

    fn visit_function_definitions(&mut self, function_definitions: &Node, symbols: &SymbolTable) {
        for function_def in function_definitions.children() {
            if let Some(NodeVal::Leaf(token)) = function_def.children()[0].val() {
                if let Some(Scope::Function(fe)) = symbols.find_scope_by_ident(token.lexeme()) {
                    self.generate_function_code(fe, function_def, symbols);
                }
            }
        }
    }

    fn visit_main_function(&mut self, main_func: &Node, symbols: &SymbolTable) {
        if let Some(Scope::Function(main)) = symbols.find_scope_by_ident("main") {
            for scope in main.table().scopes() {
                if let Scope::Variable(ve) = scope {
                    let tag: String = format!("var_{}_{}", main.ident(), ve.ident());
                    self.generator
                        .add_tagged_resource(&tag, sizeof(ve.var_type(), symbols));
                }
            }

            // Generate code for main function body
            self.generator
                .add_tagged_instruction(TaggedInstruction(Some("fn_main".to_string()), Entry));

            self.generate_statement_block_code(
                &main_func.children()[0].children()[1],
                main,
                symbols,
            );
        }

        self.generator.add_instruction(Halt);
        return;
    }

    fn generate_function_code(
        &mut self,
        fe: &FunctionEntry,
        function_definition: &Node,
        symbols: &SymbolTable,
    ) {
        // reserve memory for function return value
        self.generator.add_tagged_resource(
            &format!("fnres_{}", fe.ident()),
            sizeof(&fe.type_sig().1, symbols),
        );

        // Allocate resources for the function parameters and local variables
        for scope in fe.table().scopes().iter() {
            if let Scope::FunctionParameter(fpe) = scope {
                let tag: String = format!("param_{}_{}", fe.ident(), fpe.ident());
                self.generator
                    .add_tagged_resource(&tag, sizeof(fpe.param_type(), symbols));
            } else if let Scope::Variable(ve) = scope {
                let tag: String = format!("var_{}_{}", fe.ident(), ve.ident());
                self.generator
                    .add_tagged_resource(&tag, sizeof(ve.var_type(), symbols));
            }
        }

        // Add function body
        self.generator
            .add_tagged_instruction(TaggedInstruction(Some(format!("fn_{}", fe.ident())), NoOp));

        self.store_and_inc_fn_ptr();

        self.generate_statement_block_code(
            &function_definition.children()[4].children()[1],
            fe,
            symbols,
        ); //Statement list

        // reset local variables
        for scope in fe.table().scopes().iter() {
            if let Scope::Variable(ve) = scope {
                self.generator.add_instruction(StoreWordLabel(
                    R0,
                    R0,
                    format!("var_{}_{}", fe.ident(), ve.ident()),
                ));
            }
        }

        self.generator
            .buffer_label(&format!("fn_{}_retblock", fe.ident()));

        // jump back to callee, assuming address will be stored in R15
        self.load_and_dec_fn_ptr();
        self.generator.add_instruction(JumpRegister(R15));

        return;
    }

    fn generate_statement_block_code(
        &mut self,
        statement_block: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        for statement in statement_block.children() {
            match statement.val() {
                None => {
                    self.generator.add_instruction(NoOp);
                    break;
                }
                Some(statement_type) => match statement_type {
                    NodeVal::Leaf(_) => {
                        panic!()
                    }
                    NodeVal::Internal(ty) => match ty {
                        InternalNodeType::WhileStatement => {
                            self.generate_while_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::IfStatement => {
                            self.generate_if_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::ReadStatement => {
                            self.generate_read_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::WriteStatement => {
                            self.generate_write_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::ReturnStatement => {
                            self.generate_return_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::BreakStatement => {
                            let (_, endwhile_label) = self.label_allocator.current_while_labels();
                            self.generator.add_instruction(JumpLabel(endwhile_label));
                        }
                        InternalNodeType::ContinueStatement => {
                            let (while_label, _) = self.label_allocator.current_while_labels();
                            self.generator.add_instruction(JumpLabel(while_label));
                        }
                        InternalNodeType::GenericStatement => {
                            self.generate_generic_statement_code(statement, fe, symbols);
                        }
                        _ => panic!(),
                    },
                },
            }
        }

        return;
    }

    fn generate_while_statement_code(
        &mut self,
        while_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        let (while_label, endwhile_label) = self.label_allocator.next_while_labels();

        self.generator.buffer_label(&while_label);
        let rel_expr_res =
            self.generate_relative_expression_code(&while_statement.children()[0], fe, symbols);
        let rel_expr_reg = self.register_allocator.next_free_register();
        match rel_expr_res {
            Immediate(val) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator
                    .add_instruction(AddImmediate(rel_expr_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator.add_instruction(LoadWordLabel(
                    rel_expr_reg,
                    offset,
                    label.to_string(),
                ));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator.add_instruction(Add(rel_expr_reg, R0, r));
            }
        }
        self.generator
            .add_instruction(BranchIfZeroLabel(rel_expr_reg, endwhile_label.clone()));
        self.register_allocator.release_register(rel_expr_reg);

        // code for stat block
        self.generate_statement_block_code(&while_statement.children()[1], fe, symbols);

        self.generator
            .add_instruction(JumpLabel(while_label.clone()));
        self.generator.buffer_label(&endwhile_label);

        return;
    }

    fn generate_if_statement_code(
        &mut self,
        if_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        /*
                {code for expr yields tn as a result}
                lw r1,tn(r0)
                bz r1,else1
                {code for statblock1}
                j endif1
        else1  	{code for statblock2}
        endif1 	{code continuation}
         */
        let (if_label, else_label, endif_label) = self.label_allocator.next_if_labels();

        let rel_expr_res =
            self.generate_relative_expression_code(&if_statement.children()[0], fe, symbols);
        let rel_expr_reg = self.register_allocator.next_free_register();
        match rel_expr_res {
            Immediate(val) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator
                    .add_instruction(AddImmediate(rel_expr_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator.add_instruction(LoadWordLabel(
                    rel_expr_reg,
                    offset,
                    label.to_string(),
                ));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator
                    .add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
                self.generator.add_instruction(Add(rel_expr_reg, R0, r));
            }
        }
        self.generator.add_tagged_instruction(TaggedInstruction(
            Some(if_label),
            BranchIfZeroLabel(rel_expr_reg, else_label.clone()),
        ));
        self.register_allocator.release_register(rel_expr_reg);

        // code for then stat block
        self.generate_statement_block_code(&if_statement.children()[1], fe, symbols);
        self.generator
            .add_instruction(JumpLabel(endif_label.clone()));

        // code for else stat block
        self.generator.buffer_label(&else_label.clone());
        self.generate_statement_block_code(&if_statement.children()[2], fe, symbols);

        self.generator.buffer_label(&endif_label);

        return;
    }

    fn generate_read_statement_code(
        &mut self,
        read_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        log::error!("READ STATEMENT CODE GENERATION: NOT IMPLEMENTED");
        todo!()
    }

    fn generate_write_statement_code(
        &mut self,
        write_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        log::error!("WRITE STATEMENT CODE GENERATION: NOT IMPLEMENTED");
        todo!()
    }

    fn generate_return_statement_code(
        &mut self,
        return_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        let expr_result =
            self.generate_expression_code(&return_statement.children()[0], fe, symbols);
        let expr_result_reg = self.register_allocator.next_free_register();
        match expr_result {
            Immediate(val) => {
                self.generator.add_instruction(Substract(
                    expr_result_reg,
                    expr_result_reg,
                    expr_result_reg,
                ));
                self.generator
                    .add_instruction(AddImmediate(expr_result_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator.add_instruction(Substract(
                    expr_result_reg,
                    expr_result_reg,
                    expr_result_reg,
                ));
                self.generator.add_instruction(LoadWordLabel(
                    expr_result_reg,
                    offset,
                    label.to_string(),
                ));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator.add_instruction(Substract(
                    expr_result_reg,
                    expr_result_reg,
                    expr_result_reg,
                ));
                self.generator.add_instruction(Add(expr_result_reg, R0, r));
            }
        }
        self.generator.add_instruction(StoreWordLabel(
            expr_result_reg,
            R0,
            format!("fnres_{}", fe.ident()),
        ));
        self.register_allocator.release_register(expr_result_reg);

        self.generator
            .add_instruction(JumpLabel(format!("fn_{}_retblock", fe.ident())));

        return;
    }

    fn generate_generic_statement_code(
        &mut self,
        generic_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        // either assignment or function call
        match generic_statement.children()[0].val() {
            None => {
                panic!()
            }
            Some(val) => match val {
                NodeVal::Leaf(_) => {
                    self.generate_function_call_code(&generic_statement.children()[0], fe, symbols);
                }
                NodeVal::Internal(InternalNodeType::Assignment) => {
                    self.generate_assignment_code(&generic_statement.children()[0], fe, symbols);
                }
                NodeVal::Internal(InternalNodeType::DotOp) => {
                    let _ = self.generate_dot_operator_code(
                        &generic_statement.children()[0],
                        fe,
                        symbols,
                    );
                }
                _ => {
                    panic!()
                }
            },
        }

        return;
    }

    fn generate_function_call_code(
        &mut self,
        function_call: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let function_ident = match function_call.val() {
            Some(NodeVal::Leaf(token)) => token.lexeme(),
            _ => {
                panic!()
            }
        };

        let mut expr_results: Vec<ExprParseStorage> = Vec::new();
        for expr_node in function_call.children()[0].children() {
            match expr_node.val() {
                None => {
                    break;
                }
                Some(_) => expr_results.push(self.generate_expression_code(
                    expr_node,
                    function_entry,
                    symbols,
                )),
            }
        }

        if let Some(Scope::Function(fe)) = symbols.find_scope_by_ident(function_ident) {
            let mut param_labels: Vec<String> = Vec::new();
            for scope in fe.table().scopes() {
                if let Scope::FunctionParameter(pe) = scope {
                    param_labels.push(format!("param_{}_{}", fe.ident(), pe.ident()));
                }
            }
            assert_eq!(param_labels.len(), expr_results.len());
            for (param_label, expr_res) in param_labels.drain(..).zip(expr_results.drain(..)) {
                //todo fucking arrays
                match expr_res {
                    Immediate(imm) => {
                        let param_reg = self.register_allocator.next_free_register();
                        self.generator
                            .add_instruction(Substract(param_reg, param_reg, param_reg));
                        self.generator
                            .add_instruction(AddImmediate(param_reg, R0, imm));
                        self.generator
                            .add_instruction(StoreWordLabel(param_reg, R0, param_label));
                        self.register_allocator.release_register(param_reg);
                    }
                    Labelled(label, offs) => {
                        let expr_reg = self.register_allocator.next_free_register();
                        self.generator
                            .add_instruction(Substract(expr_reg, expr_reg, expr_reg));
                        self.generator
                            .add_instruction(LoadWordLabel(expr_reg, offs, label));
                        self.generator
                            .add_instruction(StoreWordLabel(expr_reg, R0, param_label));
                        self.register_allocator.release_register(expr_reg);
                        self.register_allocator.release_register(offs);
                    }
                    Register(r) => {
                        self.generator
                            .add_instruction(StoreWordLabel(r, R0, param_label));
                        self.register_allocator.release_register(r);
                    }
                }
            }
        } else {
            panic!()
        }

        self.generator
            .add_instruction(JumpLinkLabel(R15, format!("fn_{}", function_ident))); // jump to function

        return ExprParseStorage::Labelled(format!("fnres_{}", function_ident), R0);
    }

    fn generate_assignment_code(
        &mut self,
        assignment_statement: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        // parse right expression
        // maybe parse left expression (e.g. array indexing, data member (dot op) )
        // store rhs result register in lhs

        // usually  lw rn, rhs
        //          sw lhs, rn
        //

        let lhs: ExprParseStorage = match assignment_statement.children()[0].val() {
            Some(NodeVal::Internal(InternalNodeType::DotOp)) => self.generate_dot_operator_code(
                &assignment_statement.children()[0],
                function_entry,
                symbols,
            ),
            Some(NodeVal::Leaf(token)) => {
                match function_entry.table().find_scope_by_ident(token.lexeme()) {
                    Some(Scope::Variable(ve)) => match ve.var_type() {
                        Type::Integer | Type::Float => ExprParseStorage::Labelled(
                            format!("var_{}_{}", function_entry.ident(), ve.ident()),
                            R0,
                        ),
                        Type::String | Type::StringArray(_) => {
                            unimplemented!("String types not implemented")
                        }
                        Type::CustomArray(_, _) | Type::Custom(_) => {
                            unimplemented!("Class types not implemented")
                        }

                        Type::IntegerArray(_) | Type::FloatArray(_) => {
                            todo!("indices, follow ptr")
                        }
                        _ => panic!(),
                    },
                    Some(Scope::FunctionParameter(pe)) => match pe.param_type() {
                        Type::Integer | Type::Float => ExprParseStorage::Labelled(
                            format!("var_{}_{}", function_entry.ident(), pe.ident()),
                            R0,
                        ),
                        Type::String | Type::StringArray(_) => {
                            todo!("strings not implemented")
                        }
                        Type::CustomArray(_, _) | Type::Custom(_) => {
                            todo!("classes not implemented")
                        }

                        Type::IntegerArray(_) | Type::FloatArray(_) => {
                            todo!("indices, follow ptr")
                        }
                        _ => panic!(),
                    },
                    _ => panic!(),
                }
            }
            _ => {
                panic!()
            }
        };

        let rhs: ExprParseStorage = self.generate_expression_code(
            &assignment_statement.children()[1],
            function_entry,
            symbols,
        );

        match (lhs, rhs) {
            (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                if roffs != R0 {
                    self.generator
                        .add_instruction(LoadWordLabel(roffs, roffs, rlabel));
                    self.generator
                        .add_instruction(StoreWordLabel(roffs, loffs, llabel));
                    self.register_allocator.release_register(loffs);
                    self.register_allocator.release_register(roffs);
                } else {
                    let rreg = self.register_allocator.next_free_register();
                    self.generator.add_instruction(Substract(rreg, rreg, rreg));
                    self.generator
                        .add_instruction(LoadWordLabel(rreg, R0, rlabel));
                    self.generator
                        .add_instruction(StoreWordLabel(rreg, loffs, llabel));
                    self.register_allocator.release_register(loffs);
                    self.register_allocator.release_register(rreg);
                }
            }
            (Labelled(llabel, loffs), Immediate(imm)) => {
                let rreg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(rreg, rreg, rreg));
                self.generator.add_instruction(AddImmediate(rreg, R0, imm));
                self.generator
                    .add_instruction(StoreWordLabel(rreg, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(rreg);
            }
            (Labelled(llabel, loffs), Register(r)) => {
                self.generator
                    .add_instruction(StoreWordLabel(r, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(r);
            }
            _ => panic!(),
        }

        return;
    }

    /// Given an expression nodes, generates code for the it.
    /// Return value is where/what of the return value of the expression.
    fn generate_expression_code(
        &mut self,
        expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        match expr.children()[0].val() {
            Some(NodeVal::Internal(InternalNodeType::ArithExpr)) => {
                return self.generate_arith_expr_code(&expr.children()[0], function_entry, symbols);
            }
            Some(NodeVal::Internal(InternalNodeType::Equal))
            | Some(NodeVal::Internal(InternalNodeType::NotEqual))
            | Some(NodeVal::Internal(InternalNodeType::LessThan))
            | Some(NodeVal::Internal(InternalNodeType::LessEqualThan))
            | Some(NodeVal::Internal(InternalNodeType::GreaterThan))
            | Some(NodeVal::Internal(InternalNodeType::GreaterEqualThan)) => {
                return self.generate_relative_expression_code(
                    &expr.children()[0],
                    function_entry,
                    symbols,
                );
            }
            _ => panic!(),
        }
    }

    /// Given a relative expression node, generates code for it.
    /// Return value is where/what of the return value of the expression.
    fn generate_relative_expression_code(
        &mut self,
        rel_expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let left = self.generate_arith_expr_code(
            &rel_expr.children()[0].children()[0],
            function_entry,
            symbols,
        );
        let right = self.generate_arith_expr_code(
            &rel_expr.children()[0].children()[1],
            function_entry,
            symbols,
        );
        let temp_storage_label = self.label_allocator.next_temp_label();
        self.generator.add_tagged_resource(&temp_storage_label, 4);

        let mut lr = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(lr, lr, lr));
        let mut rr = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(rr, rr, rr));

        match (left, right) {
            (Immediate(lval), Immediate(rval)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval));
                self.generator.add_instruction(AddImmediate(rr, R0, rval));
            }
            (Immediate(lval), Labelled(rlabel, roffs)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval));
                self.generator
                    .add_instruction(LoadWordLabel(rr, roffs, rlabel));
                self.register_allocator.release_register(roffs);
            }
            (Immediate(lval), Register(_rr)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval));
                self.register_allocator.release_register(rr);
                rr = _rr;
            }
            (Labelled(llabel, loffs), Immediate(rval)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, loffs, llabel));
                self.generator.add_instruction(AddImmediate(rr, R0, rval));
                self.register_allocator.release_register(loffs);
            }
            (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, loffs, llabel));
                self.generator
                    .add_instruction(LoadWordLabel(rr, roffs, rlabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(roffs);
            }
            (Labelled(llabel, loffs), Register(_rr)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(rr);
                rr = _rr;
            }
            (Register(_lr), Immediate(rval)) => {
                self.register_allocator.release_register(lr);
                lr = _lr;

                self.generator.add_instruction(AddImmediate(rr, R0, rval));
            }
            (Register(_lr), Labelled(rlabel, roffs)) => {
                self.register_allocator.release_register(lr);
                lr = _lr;
                self.generator
                    .add_instruction(LoadWordLabel(rr, roffs, rlabel));
                self.register_allocator.release_register(roffs);
            }
            (Register(_lr), Register(_rr)) => {
                self.register_allocator.release_register(lr);
                lr = _lr;

                self.register_allocator.release_register(rr);
                rr = _rr;
            }
        }

        match rel_expr.children()[0].val() {
            Some(NodeVal::Internal(InternalNodeType::Equal)) => {
                self.generator.add_instruction(Equal(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::NotEqual)) => {
                self.generator.add_instruction(NotEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::LessThan)) => {
                self.generator.add_instruction(Less(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::LessEqualThan)) => {
                self.generator.add_instruction(LessEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::GreaterThan)) => {
                self.generator.add_instruction(Greater(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::GreaterEqualThan)) => {
                self.generator.add_instruction(GreaterEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            _ => panic!(),
        }
    }

    /// Given a dot operator node, generates code for it.
    /// Return value is in where/what of the return value of the expression.
    fn generate_dot_operator_code(
        &mut self,
        _dot_op: &Node,
        _function_entry: &FunctionEntry,
        _symbols: &SymbolTable,
    ) -> ExprParseStorage {
        log::error!("CODE GENERATION FOR DOT OPERATOR: NOT IMPLEMENTED");
        return Register(R0);
    }

    fn generate_ternary_operation_code(
        &mut self,
        ternary_op: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let (cond_label, then_label, else_label) = self.label_allocator.next_if_labels();
        let temp_label = self.label_allocator.next_temp_label();

        self.generator.buffer_label(&cond_label);
        let cond_res = self.generate_expression_code(&ternary_op.children()[0], fe, symbols);
        //todo check cond

        self.generator.buffer_label(&then_label);
        let then_res = self.generate_expression_code(&ternary_op.children()[1], fe, symbols);
        //todo store then res into temp

        self.generator.buffer_label(&else_label);
        let else_res = self.generate_expression_code(&ternary_op.children()[2], fe, symbols);
        // todo store else res into temp

        return Labelled(temp_label, R0);
    }

    fn generate_arith_expr_code(
        &mut self,
        arith_expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let mut postfix: Vec<&Node> = Vec::new();
        generate_arith_expr_postfix(arith_expr, &mut postfix);
        log::warn!("{:?}", postfix);
        let mut eval_stack: Vec<ExprParseStorage> = Vec::new();
        for postfix_token in postfix {
            if is_arith_operator(postfix_token) {
                let op2 = eval_stack.pop().unwrap();
                let op1 = eval_stack.pop().unwrap();
                let temp = self.label_allocator.next_temp_label();
                self.generator.add_tagged_resource(&temp, 4);
                let op1_reg = self.register_allocator.next_free_register();
                self.generator
                    .add_instruction(Substract(op1_reg, op1_reg, op1_reg));
                let op2_reg = self.register_allocator.next_free_register();
                self.generator
                    .add_instruction(Substract(op2_reg, op2_reg, op2_reg));

                match (op1, op2) {
                    (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                        self.generator
                            .add_instruction(LoadWordLabel(op1_reg, loffs, llabel));
                        self.generator
                            .add_instruction(LoadWordLabel(op2_reg, roffs, rlabel));
                        self.register_allocator.release_register(loffs);
                        self.register_allocator.release_register(roffs);
                    }
                    (Labelled(llabel, loffs), Immediate(rimm)) => {
                        self.generator
                            .add_instruction(LoadWordLabel(op1_reg, loffs, llabel));
                        self.generator
                            .add_instruction(AddImmediate(op2_reg, R0, rimm));
                        self.register_allocator.release_register(loffs);
                    }
                    (Immediate(limm), Labelled(rlabel, roffs)) => {
                        self.generator
                            .add_instruction(AddImmediate(op1_reg, R0, limm));
                        self.generator
                            .add_instruction(LoadWordLabel(op2_reg, roffs, rlabel));
                        self.register_allocator.release_register(roffs);
                    }
                    (Immediate(limm), Immediate(rimm)) => {
                        self.generator
                            .add_instruction(AddImmediate(op1_reg, R0, limm));
                        self.generator
                            .add_instruction(AddImmediate(op2_reg, R0, rimm));
                    }
                    _ => panic!("whoops"),
                }
                match postfix_token.val() {
                    Some(NodeVal::Internal(internal)) => match internal {
                        InternalNodeType::Add => self
                            .generator
                            .add_instruction(Add(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Sub => self
                            .generator
                            .add_instruction(Substract(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Or => self
                            .generator
                            .add_instruction(Or(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Mult => self
                            .generator
                            .add_instruction(Multiply(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Div => self
                            .generator
                            .add_instruction(Divide(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::And => self
                            .generator
                            .add_instruction(And(op1_reg, op1_reg, op2_reg)),
                        _ => panic!(),
                    },
                    _ => panic!(),
                }
                self.generator
                    .add_instruction(StoreWordLabel(op1_reg, R0, temp.clone()));
                eval_stack.push(ExprParseStorage::Labelled(temp, R0));
                self.register_allocator.release_register(op1_reg);
                self.register_allocator.release_register(op2_reg);
            } else if is_arith_operand(postfix_token) {
                match postfix_token.val() {
                    Some(NodeVal::Internal(InternalNodeType::SignedFactor)) => {
                        if let Some(NodeVal::Leaf(sign_token)) = postfix_token.children()[0].val() {
                            let sign = sign_token.lexeme();
                            match postfix_token.children()[1].val() {
                                Some(NodeVal::Leaf(val_token)) => {
                                    eval_stack.push(Immediate(format!(
                                        "{}{}",
                                        sign,
                                        val_token.lexeme()
                                    )));
                                }
                                Some(NodeVal::Internal(InternalNodeType::ArithExpr)) => {
                                    eval_stack.push(self.generate_arith_expr_code(
                                        &postfix_token.children()[1],
                                        function_entry,
                                        symbols,
                                    ));
                                }
                                _ => panic!(),
                            }
                        } else {
                            panic!()
                        }
                    }
                    Some(NodeVal::Internal(InternalNodeType::DotOp)) => {
                        eval_stack.push(self.generate_dot_operator_code(
                            postfix_token,
                            function_entry,
                            symbols,
                        ));
                    }
                    Some(NodeVal::Internal(InternalNodeType::TernaryOperation)) => {
                        eval_stack.push(self.generate_ternary_operation_code(
                            postfix_token,
                            function_entry,
                            symbols,
                        ));
                    }
                    Some(NodeVal::Leaf(token)) => {
                        //todo we have to check if it's indexing into the variable, or it's a free function call
                        match token.token_type() {
                            TokenType::Id => {
                                if let Some(Scope::Variable(ve)) =
                                    function_entry.table().find_scope_by_ident(token.lexeme())
                                {
                                    let offset: Register = match ve.var_type() {
                                        Type::Integer => R0,
                                        Type::Float => R0,
                                        Type::IntegerArray(dim) | Type::FloatArray(dim) => {
                                            todo!()
                                        }
                                        Type::String
                                        | Type::StringArray(_)
                                        | Type::Custom(_)
                                        | Type::CustomArray(_, _) => {
                                            unimplemented!(
                                                "Class and string types not implemented."
                                            );
                                        }
                                        _ => panic!(),
                                    };

                                    eval_stack.push(ExprParseStorage::Labelled(
                                        format!("var_{}_{}", function_entry.ident(), ve.ident()),
                                        offset,
                                    ));
                                } else if let Some(Scope::FunctionParameter(pe)) =
                                    function_entry.table().find_scope_by_ident(token.lexeme())
                                {
                                    let offset: Register = match pe.param_type() {
                                        Type::Integer | Type::Float => R0,
                                        Type::IntegerArray(dim) | Type::FloatArray(dim) => {
                                            todo!()
                                        }
                                        Type::String
                                        | Type::StringArray(_)
                                        | Type::Custom(_)
                                        | Type::CustomArray(_, _) => {
                                            unimplemented!(
                                                "Class and string types not implemented."
                                            );
                                        }
                                        _ => panic!(),
                                    };

                                    eval_stack.push(ExprParseStorage::Labelled(
                                        format!("param_{}_{}", function_entry.ident(), pe.ident()),
                                        offset,
                                    ));
                                } else if let Some(Scope::Function(_)) =
                                    symbols.find_scope_by_ident(token.lexeme())
                                {
                                    eval_stack.push(self.generate_function_call_code(
                                        postfix_token,
                                        function_entry,
                                        symbols,
                                    ));
                                } else {
                                    panic!()
                                }
                            }
                            TokenType::IntegerLit => {
                                eval_stack
                                    .push(ExprParseStorage::Immediate(token.lexeme().to_string()));
                            }
                            TokenType::FloatLit => {
                                log::warn!("FLOATING POINTS WILL NOT WORK PROPERLY");
                                eval_stack
                                    .push(ExprParseStorage::Immediate(token.lexeme().to_string()));
                            }
                            TokenType::StringLit => {
                                unimplemented!("String operations are not implemented.");
                            }
                            _ => {
                                log::error!("{:?}", token);
                                panic!()
                            }
                        }
                    }
                    _ => panic!(),
                }
            }
        }

        return eval_stack.pop().unwrap();
    }

    /// When jumping to a function, we store the return address from R15 into the next slot of the fn ptr stack
    fn store_and_inc_fn_ptr(&mut self) {
        self.generator
            .add_instruction(AddImmediate(R14, R14, 4.to_string()));
        self.generator
            .add_instruction(StoreWordLabel(R15, R14, "fn_ptr_stack".to_string()));
    }

    /// When returning from a function, we pop & load the return address of the top of the fn ptr stack into R15 and jump
    fn load_and_dec_fn_ptr(&mut self) {
        self.generator
            .add_instruction(LoadWordLabel(R15, R14, "fn_ptr_stack".to_string()));
        self.generator
            .add_instruction(SubstractImmediate(R14, R14, 4.to_string()));
    }
}

pub enum ExprParseStorage {
    /// An immediate value, like an integer or a float
    Immediate(String),
    /// A label, usually for local resources, and an offset
    Labelled(String, Register),
    /// A register
    Register(Register),
}
