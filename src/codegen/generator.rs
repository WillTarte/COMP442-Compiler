#![allow(dead_code)]
use crate::codegen::allocator::{LabelAllocator, RegisterAllocator};
use crate::codegen::generator::ExprParseStorage::*;
use crate::codegen::instruction_set::Instruction::{Add, AddImmediate, And, BranchIfZeroLabel, Divide, Entry, Equal, Greater, GreaterEqual, Halt, JumpLabel, JumpLinkLabel, JumpRegister, Less, LessEqual, LoadWordLabel, Multiply, NoOp, NotEqual, Or, Res, StoreWordLabel, Substract, SubstractImmediate, LoadWord, MultiplyImmediate, StoreWord, Align, Comment};
use crate::codegen::instruction_set::Register;
use crate::codegen::instruction_set::Register::*;
use crate::codegen::instruction_set::{Instruction, TaggedInstruction};
use crate::codegen::utils::{
    generate_arith_expr_postfix, is_arith_operand, is_arith_operator, sizeof,
};
use crate::lexer::token::TokenType;
use crate::parser::ast::{InternalNodeType, Node, NodeVal};
use crate::semantics::symbol_table::{ClassEntry, FunctionEntry, Scope, SymbolTable, Type, ParameterEntry};
use std::fmt;
use std::fmt::{Display, Formatter};

/// The output of the code generator
#[derive(Default)]
pub struct CodeGenOutput(Vec<TaggedInstruction>);

impl CodeGenOutput {
    pub fn append(&mut self, mut other: CodeGenOutput) {
        self.0.append(&mut other.0)
    }
    pub fn push(&mut self, inst: TaggedInstruction) {
        self.0.push(inst);
    }
}

impl IntoIterator for CodeGenOutput {
    type Item = TaggedInstruction;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Display for CodeGenOutput {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        for inst in self.0.iter() {
            write!(f, "{}\n", inst.to_string())?;
        }
        Ok(())
    }
}

/// Holds the code generated by the Moon generator
#[derive(Default)]
struct CodeGenerator {
    output: CodeGenOutput,
    resources: CodeGenOutput,
    current_label: Option<String>,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            output: CodeGenOutput::default(),
            resources: CodeGenOutput::default(),
            current_label: None,
        }
    }

    /// Adds a new tagged resource
    pub fn add_tagged_resource(&mut self, tag: &str, bytes: u32) {
        self.resources
            .0
            .push(TaggedInstruction(Some(tag.to_string()), Res(bytes)));
    }

    /// Adds a new instruction, consuming a tag if it is buffered
    pub fn add_instruction(&mut self, inst: Instruction) {
        if self.current_label.is_some() {
            let label = std::mem::replace(&mut self.current_label, None);
            self.output.0.push(TaggedInstruction(label, inst));
        } else {
            self.output.0.push(TaggedInstruction(None, inst));
        }
    }

    /// Adds a new tagged instruction
    pub fn add_tagged_instruction(&mut self, t_inst: TaggedInstruction) {
        if self.current_label.is_some() {
            log::warn!(
                "CURRENT LABEL {:?}; OTHER {:?}",
                self.current_label,
                t_inst.0
            );
            let old_label = std::mem::replace(&mut self.current_label, None);
            self.output.push(TaggedInstruction(old_label, NoOp));
        }
        self.output.0.push(t_inst);
    }

    /// Buffers a label for the next instruction
    pub fn buffer_label(&mut self, label: &str) {
        if self.current_label.is_some() {
            log::warn!("CURRENT LABEL {:?}; OTHER {}", self.current_label, label);
            let old_label = std::mem::replace(&mut self.current_label, None);
            self.output.push(TaggedInstruction(old_label, NoOp));
        }
        self.current_label = Some(label.to_string());
    }

    /// Adds a comment to the output
    pub fn add_comment(&mut self, comment: &str) {
        self.output.0.push(TaggedInstruction(None, Comment(comment.to_string())));
    }
}

/// The MOON code generator
pub struct MoonGenerator {
    label_allocator: LabelAllocator,
    register_allocator: RegisterAllocator,
    generator: CodeGenerator,
}

impl MoonGenerator {
    pub fn new() -> Self {
        Self {
            label_allocator: Default::default(),
            register_allocator: RegisterAllocator::new(),
            generator: Default::default(),
        }
    }

    /// Generates the MOON code given an AST and a symbol table
    pub fn generate(&mut self, ast: &Node, symbols: &SymbolTable) {
        log::info!("Beginning code generation");
        self.visit_class_declarations(&ast.children()[0], symbols);
        self.visit_function_definitions(&ast.children()[1], symbols);
        self.visit_main_function(&ast.children()[2], symbols);

        self.generator.add_comment(" - - - - Resources - - - -");
        self.generator.add_tagged_resource("fn_ptr_stack", 512);
    }

    /// Finishes the code generation. Returns the output.
    pub fn finish(mut self) -> CodeGenOutput {
        log::info!("Finished code generation");
        self.generator.output.append(self.generator.resources);
        self.generator.output
    }

    fn visit_class_declarations(&mut self, class_declarations: &Node, symbols: &SymbolTable) {
        for class_decl in class_declarations.children() {
            if let Some(NodeVal::Leaf(token)) = class_decl.children()[0].val() {
                if let Some(Scope::Class(ce)) = symbols.find_scope_by_ident(token.lexeme()) {
                    self.generate_class_code(ce, class_decl, symbols);
                }
            }
        }
    }

    fn generate_class_code(
        &mut self,
        _class_entry: &ClassEntry,
        _class_declaration: &Node,
        _symbols: &SymbolTable,
    ) {
        unimplemented!("Code generation for classes is not implemented");
    }

    fn visit_function_definitions(&mut self, function_definitions: &Node, symbols: &SymbolTable) {
        for function_def in function_definitions.children() {
            if let Some(NodeVal::Leaf(token)) = function_def.children()[0].val() {
                if let Some(Scope::Function(fe)) = symbols.find_scope_by_ident(token.lexeme()) {
                    self.generate_function_code(fe, function_def, symbols);
                }
            }
        }
    }

    fn visit_main_function(&mut self, main_func: &Node, symbols: &SymbolTable) {

        self.generator.add_comment(" ~ Main ~");
        if let Some(Scope::Function(main)) = symbols.find_scope_by_ident("main") {
            for scope in main.table().scopes() {
                if let Scope::Variable(ve) = scope {
                    let tag: String = format!("var_{}_{}", main.ident(), ve.ident());
                    self.generator
                        .add_tagged_resource(&tag, sizeof(ve.var_type(), symbols));
                }
            }

            self.generator.add_comment("Body");
            // Generate code for main function body
            self.generator
                .add_tagged_instruction(TaggedInstruction(Some("fn_main".to_string()), Entry));
            self.generator.add_instruction(Align);
            //self.generator.add_instruction(AddImmediate(R14, R0, "topaddr".to_string()));

            self.generate_statement_block_code(
                &main_func.children()[0].children()[1],
                main,
                symbols,
            );
        }

        self.generator.add_instruction(Halt);
        return;
    }

    fn generate_function_code(
        &mut self,
        fe: &FunctionEntry,
        function_definition: &Node,
        symbols: &SymbolTable,
    ) {
        self.generator.add_comment(&format!(" FUNCTION: {}", fe.ident()));
        // reserve memory for function return value
        self.generator.add_tagged_resource(
            &format!("fnres_{}", fe.ident()),
            sizeof(&fe.type_sig().1, symbols),
        );

        // Allocate resources for the function parameters and local variables
        for scope in fe.table().scopes().iter() {
            if let Scope::FunctionParameter(fpe) = scope {
                let tag: String = format!("param_{}_{}", fe.ident(), fpe.ident());
                self.generator
                    .add_tagged_resource(&tag, sizeof(fpe.param_type(), symbols));
            } else if let Scope::Variable(ve) = scope {
                let tag: String = format!("var_{}_{}", fe.ident(), ve.ident());
                self.generator
                    .add_tagged_resource(&tag, sizeof(ve.var_type(), symbols));
            }
        }

        // Add function body
        self.generator
            .add_tagged_instruction(TaggedInstruction(Some(format!("fn_{}", fe.ident())), NoOp));

        self.generator.add_comment("Header");

        self.store_and_inc_fn_ptr();

        self.generator.add_comment("Body");
        self.generate_statement_block_code(
            &function_definition.children()[4].children()[1],
            fe,
            symbols,
        ); //Statement list

        self.generator.add_comment("Tail");

        // reset local variables
        for scope in fe.table().scopes().iter() {
            if let Scope::Variable(ve) = scope {
                self.generator.add_instruction(StoreWordLabel(
                    R0,
                    R0,
                    format!("var_{}_{}", fe.ident(), ve.ident()),
                ));
            }
            else if let Scope::FunctionParameter(pe) = scope
            {
                self.generator.add_instruction(StoreWordLabel(
                    R0,
                    R0,
                    format!("para,_{}_{}", fe.ident(), pe.ident()),
                ));
            }
        }

        self.generator
            .buffer_label(&format!("fn_{}_retblock", fe.ident()));

        // jump back to callee, assuming address will be stored in R15
        self.load_and_dec_fn_ptr();
        self.generator.add_instruction(JumpRegister(R15));

        return;
    }

    fn generate_statement_block_code(
        &mut self,
        statement_block: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        for statement in statement_block.children() {
            match statement.val() {
                None => {
                    self.generator.add_instruction(NoOp);
                    break;
                }
                Some(statement_type) => match statement_type {
                    NodeVal::Leaf(_) => {
                        panic!()
                    }
                    NodeVal::Internal(ty) => match ty {
                        InternalNodeType::WhileStatement => {
                            self.generator.add_comment(" ~ While Statement ~");
                            self.generate_while_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::IfStatement => {
                            self.generator.add_comment(" ~ If Statement ~");
                            self.generate_if_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::ReadStatement => {
                            self.generator.add_comment(" ~ Read Statement ~");
                            self.generate_read_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::WriteStatement => {
                            self.generator.add_comment(" ~ Write Statement ~");
                            self.generate_write_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::ReturnStatement => {
                            self.generator.add_comment(" ~ Return Statement ~");
                            self.generate_return_statement_code(statement, fe, symbols);
                        }
                        InternalNodeType::BreakStatement => {
                            self.generator.add_comment(" ~ Break Statement ~");
                            let (_, endwhile_label) = self.label_allocator.current_while_labels();
                            self.generator.add_instruction(JumpLabel(endwhile_label));
                        }
                        InternalNodeType::ContinueStatement => {
                            self.generator.add_comment(" ~ Continue Statement ~");
                            let (while_label, _) = self.label_allocator.current_while_labels();
                            self.generator.add_instruction(JumpLabel(while_label));
                        }
                        InternalNodeType::GenericStatement => {
                            self.generate_generic_statement_code(statement, fe, symbols);
                        }
                        _ => panic!(),
                    },
                },
            }
        }

        return;
    }

    fn generate_while_statement_code(
        &mut self,
        while_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        let (while_label, endwhile_label) = self.label_allocator.next_while_labels();

        self.generator.buffer_label(&while_label);
        let rel_expr_res =
            self.generate_relative_expression_code(&while_statement.children()[0].children()[0], fe, symbols);
        let rel_expr_reg = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
        match rel_expr_res {
            Immediate(val) => {
                self.generator.add_instruction(AddImmediate(rel_expr_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator.add_instruction(LoadWordLabel(rel_expr_reg, offset, label.to_string()));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator.add_instruction(Add(rel_expr_reg, R0, r));
                self.register_allocator.release_register(r);
            }
            Pointer(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(rel_expr_reg, R0, label)); // load address
                self.generator.add_instruction(Add(rel_expr_reg, rel_expr_reg, offs)); // add offset
                self.generator.add_instruction(LoadWord(rel_expr_reg, rel_expr_reg, 0)); // load actual value at memory location
                self.register_allocator.release_register(offs);
            }
        }
        self.generator.add_instruction(BranchIfZeroLabel(rel_expr_reg, endwhile_label.clone()));
        self.register_allocator.release_register(rel_expr_reg);

        // code for stat block
        self.generate_statement_block_code(&while_statement.children()[1], fe, symbols);

        self.generator
            .add_instruction(JumpLabel(while_label.clone()));
        self.generator.buffer_label(&endwhile_label);

        return;
    }

    fn generate_if_statement_code(
        &mut self,
        if_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        /*
                {code for expr yields tn as a result}
                lw r1,tn(r0)
                bz r1,else1
                {code for statblock1}
                j endif1
        else1  	{code for statblock2}
        endif1 	{code continuation}
         */
        let (if_label, else_label, endif_label) = self.label_allocator.next_if_labels();

        let rel_expr_res =
            self.generate_relative_expression_code(&if_statement.children()[0].children()[0], fe, symbols);
        let rel_expr_reg = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(rel_expr_reg, rel_expr_reg, rel_expr_reg));
        match rel_expr_res {
            Immediate(val) => {
                self.generator.add_instruction(AddImmediate(rel_expr_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator.add_instruction(LoadWordLabel(rel_expr_reg, offset, label.to_string()));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator.add_instruction(Add(rel_expr_reg, R0, r));
                self.register_allocator.release_register(r);
            }
            Pointer(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(rel_expr_reg, R0, label)); // load address
                self.generator.add_instruction(Add(rel_expr_reg, rel_expr_reg, offs)); // add offset
                self.generator.add_instruction(LoadWord(rel_expr_reg, rel_expr_reg, 0)); // load actual value at memory location
                self.register_allocator.release_register(offs);
            }
        }
        self.generator.add_tagged_instruction(TaggedInstruction(
            Some(if_label),
            BranchIfZeroLabel(rel_expr_reg, else_label.clone()),
        ));
        self.register_allocator.release_register(rel_expr_reg);

        // code for then stat block
        self.generate_statement_block_code(&if_statement.children()[1], fe, symbols);
        self.generator
            .add_instruction(JumpLabel(endif_label.clone()));

        // code for else stat block
        self.generator.buffer_label(&else_label.clone());
        self.generate_statement_block_code(&if_statement.children()[2], fe, symbols);

        self.generator.buffer_label(&endif_label);

        return;
    }

    fn generate_read_statement_code(
        &mut self,
        read_statement: &Node,
        fe: &FunctionEntry,
        _symbols: &SymbolTable,
    ) {
        match read_statement.children()[0].children()[0].val()
        {
            Some(NodeVal::Leaf(token)) => {
                if let Some(Scope::Variable(ve)) = fe.table().find_scope_by_ident(token.lexeme())
                {
                    self.generator.add_instruction(JumpLinkLabel(R15, "getint".to_string()));
                    self.generator.add_instruction(StoreWordLabel(R1, R0, format!("var_{}_{}", fe.ident(), ve.ident())));
                }
                else if let Some(Scope::FunctionParameter(pe)) = fe.table().find_scope_by_ident(token.lexeme())
                {
                    self.generator.add_instruction(JumpLinkLabel(R15, "getint".to_string()));
                    self.generator.add_instruction(StoreWordLabel(R1, R0, format!("param_{}_{}", fe.ident(), pe.ident())));
                }
            },
            _ => log::error!("INVALID READ VARIABLE")
        }
    }

    fn generate_write_statement_code(
        &mut self,
        write_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        let expr_res = self.generate_expression_code(&write_statement.children()[0], fe, symbols);
        self.generator.add_instruction(Substract(R1, R1, R1));
        match expr_res
        {
            Immediate(imm) => {

                self.generator.add_instruction(AddImmediate(R1, R0, imm));
            }
            Labelled(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(R1, offs, label));
                self.register_allocator.release_register(offs);
            }
            Register(r) => {
                self.generator.add_instruction(Add(R1, R0, r));
                self.register_allocator.release_register(r);
            }
            Pointer(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(R1, R0, label));
                self.generator.add_instruction(Add(R1, R1, offs));
                self.register_allocator.release_register(offs);
            }
        }
        self.generator.add_instruction(JumpLinkLabel(R15, "putint".to_string()));
    }

    fn generate_return_statement_code(
        &mut self,
        return_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        let expr_result =
            self.generate_expression_code(&return_statement.children()[0], fe, symbols);
        let expr_result_reg = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(expr_result_reg, expr_result_reg, expr_result_reg));
        match expr_result {
            Immediate(val) => {
                self.generator.add_instruction(AddImmediate(expr_result_reg, R0, val));
            }
            Labelled(label, offset) => {
                self.generator.add_instruction(LoadWordLabel(expr_result_reg, offset, label.to_string()));
                self.register_allocator.release_register(offset);
            }
            Register(r) => {
                self.generator.add_instruction(Add(expr_result_reg, R0, r));
                self.register_allocator.release_register(r);
            }
            Pointer(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(expr_result_reg, R0, label)); // load address
                self.generator.add_instruction(Add(expr_result_reg, expr_result_reg, offs)); // add offset
                self.generator.add_instruction(LoadWord(expr_result_reg, expr_result_reg, 0)); // load actual value at memory location
                self.register_allocator.release_register(offs);
            }
        }
        self.generator.add_instruction(StoreWordLabel(
            expr_result_reg,
            R0,
            format!("fnres_{}", fe.ident()),
        ));
        self.register_allocator.release_register(expr_result_reg);

        self.generator
            .add_instruction(JumpLabel(format!("fn_{}_retblock", fe.ident())));

        return;
    }

    fn generate_generic_statement_code(
        &mut self,
        generic_statement: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        // either assignment or function call
        match generic_statement.children()[0].val() {
            None => {
                panic!()
            }
            Some(val) => match val {
                NodeVal::Leaf(_) => {
                    self.generator.add_comment(" ~ Function Call Statement ~");
                    self.generate_function_call_code(&generic_statement.children()[0], fe, symbols);
                }
                NodeVal::Internal(InternalNodeType::Assignment) => {
                    self.generator.add_comment(" ~ Assignment Statement ~");
                    self.generate_assignment_code(&generic_statement.children()[0], fe, symbols);
                }
                NodeVal::Internal(InternalNodeType::DotOp) => {
                    let _ = self.generate_dot_operator_code(
                        &generic_statement.children()[0],
                        fe,
                        symbols,
                    );
                }
                _ => {
                    panic!()
                }
            },
        }

        return;
    }

    fn generate_function_call_code(
        &mut self,
        function_call: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let function_ident = match function_call.val() {
            Some(NodeVal::Leaf(token)) => token.lexeme(),
            _ => {
                panic!()
            }
        };

        let mut expr_results: Vec<ExprParseStorage> = Vec::new();
        for expr_node in function_call.children()[0].children() {
            match expr_node.val() {
                None => {
                    break;
                }
                Some(_) => expr_results.push(self.generate_expression_code(
                    expr_node,
                    function_entry,
                    symbols,
                )),
            }
        }

        if let Some(Scope::Function(fe)) = symbols.find_scope_by_ident(function_ident) {
            let mut params: Vec<&ParameterEntry> = Vec::new();
            for scope in fe.table().scopes() {
                if let Scope::FunctionParameter(pe) = scope {
                    params.push(pe);
                }
            }
            assert_eq!(params.len(), expr_results.len());
            for (param, expr_res) in params.drain(..).zip(expr_results.drain(..)) {
                let param_label = format!("param_{}_{}", fe.ident(), param.ident());
                self.generator.add_comment(&format!("Storing into function parameter {}", param_label));
                match expr_res {
                    Immediate(imm) => {
                        let param_reg = self.register_allocator.next_free_register();
                        self.generator.add_instruction(Substract(param_reg, param_reg, param_reg));
                        self.generator.add_instruction(AddImmediate(param_reg, R0, imm));
                        self.generator.add_instruction(StoreWordLabel(param_reg, R0, param_label));
                        self.register_allocator.release_register(param_reg);
                    }
                    Labelled(label, offs) => {
                        match param.param_type() {
                            Type::IntegerArray(_)
                            | Type::FloatArray(_) => {
                                self.generator.add_instruction(AddImmediate(offs, offs, label));
                                self.generator.add_instruction(StoreWordLabel(offs, R0, param_label));
                                self.register_allocator.release_register(offs);
                            }
                            Type::Float | Type::Integer => {
                                let expr_reg = self.register_allocator.next_free_register();
                                self.generator.add_instruction(Substract(expr_reg, expr_reg, expr_reg));
                                self.generator.add_instruction(LoadWordLabel(expr_reg, offs, label));
                                self.generator.add_instruction(StoreWordLabel(expr_reg, R0, param_label));
                                self.register_allocator.release_register(expr_reg);
                                self.register_allocator.release_register(offs);
                            }
                            Type::String
                            | Type::StringArray(_)
                            | Type::Custom(_)
                            | Type::CustomArray(_, _) => { unimplemented!("Class and String not implemented") },
                            _ => panic!()
                        }
                    }
                    Register(r) => {
                        self.generator.add_instruction(StoreWordLabel(r, R0, param_label));
                        self.register_allocator.release_register(r);
                    }
                    Pointer(label, offs) => {
                        // copy the pointer into the param
                        let ptr_reg = self.register_allocator.next_free_register();
                        self.generator.add_instruction(Substract(ptr_reg, ptr_reg, ptr_reg));
                        self.generator.add_instruction(LoadWordLabel(ptr_reg, R0, label));
                        self.generator.add_instruction(Add(ptr_reg, ptr_reg, offs));
                        self.generator.add_instruction(StoreWordLabel(ptr_reg, R0, param_label));
                        self.register_allocator.release_register(ptr_reg);
                        self.register_allocator.release_register(offs);
                    }
                }
            }
        } else {
            panic!()
        }

        self.generator
            .add_instruction(JumpLinkLabel(R15, format!("fn_{}", function_ident))); // jump to function

        return ExprParseStorage::Labelled(format!("fnres_{}", function_ident), R0);
    }

    fn generate_assignment_code(
        &mut self,
        assignment_statement: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) {
        // parse right expression
        // maybe parse left expression (e.g. array indexing, data member (dot op) )
        // store rhs result register in lhs

        // usually  lw rn, rhs
        //          sw lhs, rn
        //

        let lhs: ExprParseStorage = match assignment_statement.children()[0].val() {
            Some(NodeVal::Internal(InternalNodeType::DotOp)) => self.generate_dot_operator_code(
                &assignment_statement.children()[0],
                function_entry,
                symbols,
            ),
            Some(NodeVal::Leaf(token)) => {
                match function_entry.table().find_scope_by_ident(token.lexeme()) {
                    Some(Scope::Variable(ve)) => match ve.var_type() {
                        Type::Integer | Type::Float => ExprParseStorage::Labelled(
                            format!("var_{}_{}", function_entry.ident(), ve.ident()),
                            R0,
                        ),
                        Type::String | Type::StringArray(_) => {
                            unimplemented!("String types not implemented")
                        }
                        Type::CustomArray(_, _) | Type::Custom(_) => {
                            unimplemented!("Class types not implemented")
                        }

                        Type::IntegerArray(_dim) | Type::FloatArray(_dim) => {
                            let idx_res: ExprParseStorage = self.generate_array_indexing_code(ve.var_type(), &assignment_statement.children()[0], function_entry, symbols);
                            match idx_res
                            {
                                Register(offs_reg) => {
                                    // for local variables, no need for pointer indirection
                                    ExprParseStorage::Labelled(format!("var_{}_{}", function_entry.ident(), ve.ident()), offs_reg)
                                },
                                _ => panic!("Array index was not stored in a register")
                            }
                        }
                        _ => panic!(),
                    },
                    Some(Scope::FunctionParameter(pe)) => match pe.param_type() {
                        Type::Integer | Type::Float => ExprParseStorage::Labelled(
                            format!("param_{}_{}", function_entry.ident(), pe.ident()),
                            R0,
                        ),
                        Type::String | Type::StringArray(_) => {
                            unimplemented!("String types not implemented")
                        }
                        Type::CustomArray(_, _) | Type::Custom(_) => {
                            unimplemented!("Class types not implemented")
                        }

                        Type::IntegerArray(dim) | Type::FloatArray(dim) => {
                            let idx_res: ExprParseStorage = self.generate_array_indexing_code(pe.param_type(), &assignment_statement.children()[0], function_entry, symbols);
                            match idx_res
                            {
                                Register(offs_reg) => {
                                    //for function params, the data is stored elsewhere so we need indirection}
                                    ExprParseStorage::Pointer(format!("param_{}_{}", function_entry.ident(), pe.ident()), offs_reg)
                                },
                                _ => panic!("Array index was not stored in a register")
                            }
                        }
                        _ => panic!(),
                    },
                    _ => panic!(),
                }
            }
            _ => {
                panic!()
            }
        };

        let rhs: ExprParseStorage = self.generate_expression_code(
            &assignment_statement.children()[1],
            function_entry,
            symbols,
        );

        self.generator.add_comment(&format!("{:?} = {:?}", lhs, rhs));
        match (lhs, rhs) {
            (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                let rhs_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(LoadWordLabel(rhs_reg, roffs, rlabel));
                self.generator.add_instruction(StoreWordLabel(rhs_reg, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(roffs);
                self.register_allocator.release_register(rhs_reg);
            }
            (Labelled(llabel, loffs), Immediate(imm)) => {
                let rreg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(rreg, rreg, rreg));
                self.generator.add_instruction(AddImmediate(rreg, R0, imm));
                self.generator
                    .add_instruction(StoreWordLabel(rreg, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(rreg);
            }
            (Labelled(llabel, loffs), Register(r)) => {
                self.generator.add_instruction(StoreWordLabel(r, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(r);
            },
            (Labelled(llabel, loffs), Pointer(rlabel, roffs)) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(LoadWordLabel(temp_reg, R0, rlabel)); // load address into register
                self.generator.add_instruction(Add(temp_reg, temp_reg, roffs)); // add offset
                self.generator.add_instruction(LoadWord(temp_reg, temp_reg, 0)); // load actual value
                self.generator.add_instruction(StoreWordLabel(temp_reg, loffs, llabel));
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(roffs);
            },
            (Pointer(llabel, loffs), Pointer(rlabel, roffs)) => {
                let lhs_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(lhs_reg, lhs_reg, lhs_reg));
                let rhs_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(rhs_reg, rhs_reg, rhs_reg));

                self.generator.add_instruction(LoadWordLabel(lhs_reg, R0, llabel)); // load address into register
                self.generator.add_instruction(Add(lhs_reg, lhs_reg, loffs)); // add offset

                self.generator.add_instruction(LoadWordLabel(rhs_reg, R0, rlabel)); // load address into register
                self.generator.add_instruction(Add(rhs_reg, rhs_reg, roffs)); // add offset
                self.generator.add_instruction(LoadWord(rhs_reg, rhs_reg, 0)); // load actual value

                // M[0 + lhs_reg] <- rhs_reg
                self.generator.add_instruction(StoreWord(rhs_reg, lhs_reg, 0));

                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(roffs);
                self.register_allocator.release_register(lhs_reg);
                self.register_allocator.release_register(rhs_reg);
            },
            (Pointer(llabel, loffs), Labelled(rlabel, roffs)) => {
                let lhs_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(lhs_reg, lhs_reg, lhs_reg));
                let rhs_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(rhs_reg, rhs_reg, rhs_reg));

                self.generator.add_instruction(LoadWordLabel(lhs_reg, R0, llabel)); // load address into register
                self.generator.add_instruction(Add(lhs_reg, lhs_reg, loffs)); // add offset

                self.generator.add_instruction(LoadWordLabel(rhs_reg, roffs, rlabel));

                // M[0 + lhs_reg] <- rhs_reg
                self.generator.add_instruction(StoreWord(rhs_reg, lhs_reg, 0));

                self.register_allocator.release_register(lhs_reg);
                self.register_allocator.release_register(rhs_reg);
                self.register_allocator.release_register(loffs);
                self.register_allocator.release_register(roffs);
            },
            _ => panic!(),
        }

        return;
    }

    /// Given an expression nodes, generates code for the it.
    /// Return value is where/what of the return value of the expression.
    fn generate_expression_code(
        &mut self,
        expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        match expr.children()[0].val() {
            Some(NodeVal::Internal(InternalNodeType::ArithExpr)) => {
                return self.generate_arith_expr_code(&expr.children()[0], function_entry, symbols);
            }
            Some(NodeVal::Internal(InternalNodeType::Equal))
            | Some(NodeVal::Internal(InternalNodeType::NotEqual))
            | Some(NodeVal::Internal(InternalNodeType::LessThan))
            | Some(NodeVal::Internal(InternalNodeType::LessEqualThan))
            | Some(NodeVal::Internal(InternalNodeType::GreaterThan))
            | Some(NodeVal::Internal(InternalNodeType::GreaterEqualThan)) => {
                return self.generate_relative_expression_code(
                    &expr.children()[0],
                    function_entry,
                    symbols,
                );
            }
            _ => panic!(),
        }
    }

    /// Given a relative expression node, generates code for it.
    /// Return value is where/what of the return value of the expression.
    fn generate_relative_expression_code(
        &mut self,
        rel_expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let left = self.generate_arith_expr_code(
            &rel_expr.children()[0],
            function_entry,
            symbols,
        );
        let right = self.generate_arith_expr_code(
            &rel_expr.children()[1],
            function_entry,
            symbols,
        );
        let temp_storage_label = self.label_allocator.next_temp_label();
        self.generator.add_tagged_resource(&temp_storage_label, 4);

        let mut lr = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(lr, lr, lr));
        let mut rr = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(rr, rr, rr));

        match (&left, &right) {
            (Immediate(lval), Immediate(rval)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval.clone()));
                self.generator.add_instruction(AddImmediate(rr, R0, rval.clone()));
            }
            (Immediate(lval), Labelled(rlabel, roffs)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval.clone()));
                self.generator.add_instruction(LoadWordLabel(rr, *roffs, rlabel.clone()));
                self.register_allocator.release_register(*roffs);
            }
            (Immediate(lval), Register(_rr)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval.clone()));
                self.register_allocator.release_register(rr);
                rr = *_rr;
            }
            (Immediate(lval), Pointer(rlabel, roffs)) => {
                self.generator.add_instruction(AddImmediate(lr, R0, lval.clone()));

                self.generator.add_instruction(LoadWordLabel(rr, R0, rlabel.clone())); // load address
                self.generator.add_instruction(Add(rr, rr, *roffs)); // add offset
                self.generator.add_instruction(LoadWord(rr, rr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*roffs);
            }
            (Labelled(llabel, loffs), Immediate(rval)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, *loffs, llabel.clone()));
                self.generator.add_instruction(AddImmediate(rr, R0, rval.clone()));
                self.register_allocator.release_register(*loffs);
            }
            (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, *loffs, llabel.clone()));
                self.generator
                    .add_instruction(LoadWordLabel(rr, *roffs, rlabel.clone()));
                self.register_allocator.release_register(*loffs);
                self.register_allocator.release_register(*roffs);
            }
            (Labelled(llabel, loffs), Pointer(rlabel, roffs)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, *loffs, llabel.clone()));
                self.register_allocator.release_register(*loffs);

                self.generator.add_instruction(LoadWordLabel(rr, R0, rlabel.clone())); // load address
                self.generator.add_instruction(Add(rr, rr, *roffs)); // add offset
                self.generator.add_instruction(LoadWord(rr, rr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*roffs);
            },
            (Labelled(llabel, loffs), Register(_rr)) => {
                self.generator
                    .add_instruction(LoadWordLabel(lr, *loffs, llabel.clone()));
                self.register_allocator.release_register(*loffs);
                self.register_allocator.release_register(rr);
                rr = *_rr;
            }
            (Register(_lr), Immediate(rval)) => {
                self.register_allocator.release_register(lr);
                lr = *_lr;

                self.generator.add_instruction(AddImmediate(rr, R0, rval.clone()));
            }
            (Register(_lr), Labelled(rlabel, roffs)) => {
                self.register_allocator.release_register(lr);
                lr = *_lr;
                self.generator
                    .add_instruction(LoadWordLabel(rr, *roffs, rlabel.clone()));
                self.register_allocator.release_register(*roffs);
            }
            (Register(_lr), Register(_rr)) => {
                self.register_allocator.release_register(lr);
                lr = *_lr;

                self.register_allocator.release_register(rr);
                rr = *_rr;
            }
            (Register(_lr), Pointer(rlabel, roffs)) => {
                self.register_allocator.release_register(lr);
                lr = *_lr;

                self.generator.add_instruction(LoadWordLabel(rr, R0, rlabel.clone())); // load address
                self.generator.add_instruction(Add(rr, rr, *roffs)); // add offset
                self.generator.add_instruction(LoadWord(rr, rr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*roffs);
            }
            (Pointer(llabel, loffs), Immediate(rval)) => {
                self.generator.add_instruction(LoadWordLabel(lr, R0, llabel.clone())); // load address
                self.generator.add_instruction(Add(lr, lr, *loffs)); // add offset
                self.generator.add_instruction(LoadWord(lr, lr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*loffs);

                self.generator.add_instruction(AddImmediate(rr, R0, rval.clone()));
            }
            (Pointer(llabel, loffs), Labelled(rlabel, roffs)) => {
                self.generator.add_instruction(LoadWordLabel(lr, R0, llabel.clone())); // load address
                self.generator.add_instruction(Add(lr, lr, *loffs)); // add offset
                self.generator.add_instruction(LoadWord(lr, lr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*loffs);

                self.generator.add_instruction(LoadWordLabel(rr, *roffs, rlabel.clone()));
                self.register_allocator.release_register(*roffs);
            }
            (Pointer(llabel, loffs), Register(_rr)) => {
                self.generator.add_instruction(LoadWordLabel(lr, R0, llabel.clone())); // load address
                self.generator.add_instruction(Add(lr, lr, *loffs)); // add offset
                self.generator.add_instruction(LoadWord(lr, lr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*loffs);

                self.register_allocator.release_register(rr);
                rr = *_rr;
            }
            (Pointer(llabel, loffs), Pointer(rlabel, roffs)) => {
                self.generator.add_instruction(LoadWordLabel(lr, R0, llabel.clone())); // load address
                self.generator.add_instruction(Add(lr, lr, *loffs)); // add offset
                self.generator.add_instruction(LoadWord(lr, lr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*loffs);

                self.generator.add_instruction(LoadWordLabel(rr, R0, rlabel.clone())); // load address
                self.generator.add_instruction(Add(rr, rr, *roffs)); // add offset
                self.generator.add_instruction(LoadWord(rr, rr, 0)); // load actual value at memory location
                self.register_allocator.release_register(*roffs);
            }
        }

        match rel_expr.val() {
            Some(NodeVal::Internal(InternalNodeType::Equal)) => {
                self.generator.add_comment(&format!("{:?} == {:?}", left, right));
                self.generator.add_instruction(Equal(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::NotEqual)) => {
                self.generator.add_comment(&format!("{:?} <> {:?}", left, right));
                self.generator.add_instruction(NotEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::LessThan)) => {
                self.generator.add_comment(&format!("{:?} < {:?}", left, right));
                self.generator.add_instruction(Less(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::LessEqualThan)) => {
                self.generator.add_comment(&format!("{:?} <= {:?}", left, right));
                self.generator.add_instruction(LessEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::GreaterThan)) => {
                self.generator.add_comment(&format!("{:?} > {:?}", left, right));
                self.generator.add_instruction(Greater(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            Some(NodeVal::Internal(InternalNodeType::GreaterEqualThan)) => {
                self.generator.add_comment(&format!("{:?} >= {:?}", left, right));
                self.generator.add_instruction(GreaterEqual(lr, lr, rr));
                self.register_allocator.release_register(rr);
                return ExprParseStorage::Register(lr);
            }
            _ => panic!(),
        }
    }

    /// Given a dot operator node, generates code for it.
    /// Return value is in where/what of the return value of the expression.
    fn generate_dot_operator_code(
        &mut self,
        _dot_op: &Node,
        _function_entry: &FunctionEntry,
        _symbols: &SymbolTable,
    ) -> ExprParseStorage {
        log::error!("CODE GENERATION FOR DOT OPERATOR: NOT IMPLEMENTED");
        return Register(R0);
    }

    fn generate_ternary_operation_code(
        &mut self,
        ternary_op: &Node,
        fe: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        self.generator.add_comment("Ternary Operator");
        let (cond_label, then_label, else_label) = self.label_allocator.next_if_labels();
        let temp_label = self.label_allocator.next_temp_label();
        self.generator.add_tagged_resource(&temp_label, 4);

        let cond_reg = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(cond_reg, cond_reg, cond_reg));

        self.generator.buffer_label(&cond_label);
        let cond_res = self.generate_expression_code(&ternary_op.children()[0], fe, symbols);

        match &cond_res
        {
            Immediate(val) => {
                self.generator.add_instruction(AddImmediate(cond_reg, R0, val.clone()));
            }
            Labelled(label, offset) => {
                self.generator.add_instruction(LoadWordLabel(cond_reg, *offset, label.to_string()));
                self.register_allocator.release_register(*offset);
            }
            Register(r) => {
                self.generator.add_instruction(Add(cond_reg, R0, *r));
                self.register_allocator.release_register(*r);
            }
            Pointer(label, offs) => {
                self.generator.add_instruction(LoadWordLabel(cond_reg, R0, label.clone())); // load address
                self.generator.add_instruction(Add(cond_reg, cond_reg, *offs)); // add offset
                self.generator.add_instruction(LoadWord(cond_reg, cond_reg, 0)); // load actual value at memory location
                self.register_allocator.release_register(*offs);
            }
        }
        self.generator.add_instruction(BranchIfZeroLabel(cond_reg, else_label.clone()));
        self.register_allocator.release_register(cond_reg);

        self.generator.buffer_label(&then_label);
        let then_res = self.generate_expression_code(&ternary_op.children()[1], fe, symbols);
        match &then_res
        {
            Immediate(imm) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(AddImmediate(temp_reg, temp_reg, imm.clone()));
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(temp_reg);
            }
            Labelled(label, offs) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(LoadWordLabel(temp_reg, *offs, label.clone()));
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(*offs);
                self.register_allocator.release_register(temp_reg);
            }
            Register(r) => {
                self.generator.add_instruction(StoreWordLabel(*r, R0, temp_label.clone()));
                self.register_allocator.release_register(*r);
            }
            Pointer(label, offs) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(LoadWordLabel(temp_reg, R0, label.clone())); // load address
                self.generator.add_instruction(Add(temp_reg, temp_reg, *offs)); // add offset
                self.generator.add_instruction(LoadWord(temp_reg, temp_reg, 0)); // load actual value at memory location
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(*offs);
                self.register_allocator.release_register(temp_reg);
            }
        }

        self.generator.buffer_label(&else_label);
        let else_res = self.generate_expression_code(&ternary_op.children()[2], fe, symbols);
        match &else_res
        {
            Immediate(imm) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(AddImmediate(temp_reg, temp_reg, imm.clone()));
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(temp_reg);
            }
            Labelled(label, offs) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(LoadWordLabel(temp_reg, *offs, label.clone()));
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(*offs);
                self.register_allocator.release_register(temp_reg);
            }
            Register(r) => {
                self.generator.add_instruction(StoreWordLabel(*r, R0, temp_label.clone()));
                self.register_allocator.release_register(*r);
            }
            Pointer(label, offs) => {
                let temp_reg = self.register_allocator.next_free_register();
                self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                self.generator.add_instruction(LoadWordLabel(temp_reg, R0, label.clone())); // load address
                self.generator.add_instruction(Add(temp_reg, temp_reg, *offs)); // add offset
                self.generator.add_instruction(LoadWord(temp_reg, temp_reg, 0)); // load actual value at memory location
                self.generator.add_instruction(StoreWordLabel(temp_reg, R0, temp_label.clone()));
                self.register_allocator.release_register(*offs);
                self.register_allocator.release_register(temp_reg);
            }
        }
        self.generator.add_comment(&format!(" ^^^ ?[ {:?} : {:?} : {:?} ] ^^^", cond_res, then_res, else_res));
        return Labelled(temp_label, R0);
    }

    fn generate_arith_expr_code(
        &mut self,
        arith_expr: &Node,
        function_entry: &FunctionEntry,
        symbols: &SymbolTable,
    ) -> ExprParseStorage {
        let mut postfix: Vec<&Node> = Vec::new();
        generate_arith_expr_postfix(arith_expr, &mut postfix);
        let mut eval_stack: Vec<ExprParseStorage> = Vec::new();
        for postfix_node in postfix {
            if is_arith_operator(postfix_node) {
                let op2 = eval_stack.pop().unwrap();
                let op1 = eval_stack.pop().unwrap();
                let temp = self.label_allocator.next_temp_label();
                self.generator.add_tagged_resource(&temp, 4);
                let op1_reg = self.register_allocator.next_free_register();
                self.generator
                    .add_instruction(Substract(op1_reg, op1_reg, op1_reg));
                let op2_reg = self.register_allocator.next_free_register();
                self.generator
                    .add_instruction(Substract(op2_reg, op2_reg, op2_reg));

                match (op1, op2) {
                    (Labelled(llabel, loffs), Labelled(rlabel, roffs)) => {
                        self.generator
                            .add_instruction(LoadWordLabel(op1_reg, loffs, llabel));
                        self.generator
                            .add_instruction(LoadWordLabel(op2_reg, roffs, rlabel));
                        self.register_allocator.release_register(loffs);
                        self.register_allocator.release_register(roffs);
                    }
                    (Labelled(llabel, loffs), Immediate(rimm)) => {
                        self.generator
                            .add_instruction(LoadWordLabel(op1_reg, loffs, llabel));
                        self.generator
                            .add_instruction(AddImmediate(op2_reg, R0, rimm));
                        self.register_allocator.release_register(loffs);
                    }
                    (Labelled(llabel, loffs), Pointer(rlabel, roffs)) => {
                        self.generator.add_instruction(LoadWordLabel(op1_reg, loffs, llabel));

                        self.generator.add_instruction(LoadWordLabel(op2_reg, R0, rlabel));
                        self.generator.add_instruction(Add(op2_reg, op2_reg, roffs));
                        self.generator.add_instruction(LoadWord(op2_reg, op2_reg, 0));

                        self.register_allocator.release_register(loffs);
                        self.register_allocator.release_register(roffs);
                    }
                    (Immediate(limm), Labelled(rlabel, roffs)) => {
                        self.generator
                            .add_instruction(AddImmediate(op1_reg, R0, limm));
                        self.generator
                            .add_instruction(LoadWordLabel(op2_reg, roffs, rlabel));
                        self.register_allocator.release_register(roffs);
                    }
                    (Immediate(limm), Immediate(rimm)) => {
                        self.generator
                            .add_instruction(AddImmediate(op1_reg, R0, limm));
                        self.generator
                            .add_instruction(AddImmediate(op2_reg, R0, rimm));
                    }
                    (Immediate(limm), Pointer(rlabel, roffs)) => {
                        self.generator.add_instruction(AddImmediate(op1_reg, R0, limm));

                        self.generator.add_instruction(LoadWordLabel(op2_reg, R0, rlabel));
                        self.generator.add_instruction(Add(op2_reg, op2_reg, roffs));
                        self.generator.add_instruction(LoadWord(op2_reg, op2_reg, 0));

                        self.register_allocator.release_register(roffs);
                    },
                    (Pointer(llabel, loffs), Pointer(rlabel, roffs)) =>
                    {
                        self.generator.add_instruction(LoadWordLabel(op1_reg, R0, llabel));
                        self.generator.add_instruction(Add(op1_reg, op1_reg, loffs));
                        self.generator.add_instruction(LoadWord(op1_reg, op1_reg, 0));

                        self.generator.add_instruction(LoadWordLabel(op2_reg, R0, rlabel));
                        self.generator.add_instruction(Add(op2_reg, op2_reg, roffs));
                        self.generator.add_instruction(LoadWord(op2_reg, op2_reg, 0));

                        self.register_allocator.release_register(loffs);
                        self.register_allocator.release_register(roffs);
                    },
                    (Pointer(llabel, loffs), Labelled(rlabel, roffs)) =>
                    {
                        self.generator.add_instruction(LoadWordLabel(op1_reg, R0, llabel));
                        self.generator.add_instruction(Add(op1_reg, op1_reg, loffs));
                        self.generator.add_instruction(LoadWord(op1_reg, op1_reg, 0));

                        self.generator.add_instruction(LoadWordLabel(op2_reg, roffs, rlabel));

                        self.register_allocator.release_register(loffs);
                        self.register_allocator.release_register(roffs);
                    },
                    (Pointer(llabel, loffs), Immediate(rimm)) =>
                    {
                        self.generator.add_instruction(LoadWordLabel(op1_reg, R0, llabel));
                        self.generator.add_instruction(Add(op1_reg, op1_reg, loffs));
                        self.generator.add_instruction(LoadWord(op1_reg, op1_reg, 0));

                        self.generator.add_instruction(AddImmediate(op2_reg, R0, rimm));

                        self.register_allocator.release_register(loffs);
                    },
                    _ => panic!()
                }
                match postfix_node.val() {
                    Some(NodeVal::Internal(internal)) => match internal {
                        InternalNodeType::Add => self
                            .generator
                            .add_instruction(Add(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Sub => self
                            .generator
                            .add_instruction(Substract(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Or => self
                            .generator
                            .add_instruction(Or(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Mult => self
                            .generator
                            .add_instruction(Multiply(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::Div => self
                            .generator
                            .add_instruction(Divide(op1_reg, op1_reg, op2_reg)),
                        InternalNodeType::And => self
                            .generator
                            .add_instruction(And(op1_reg, op1_reg, op2_reg)),
                        _ => panic!(),
                    },
                    _ => panic!(),
                }
                self.generator.add_instruction(StoreWordLabel(op1_reg, R0, temp.clone()));
                eval_stack.push(ExprParseStorage::Labelled(temp, R0));
                self.register_allocator.release_register(op1_reg);
                self.register_allocator.release_register(op2_reg);
            } else if is_arith_operand(postfix_node) {
                match postfix_node.val() {
                    Some(NodeVal::Internal(InternalNodeType::SignedFactor)) => {
                        if let Some(NodeVal::Leaf(sign_token)) = postfix_node.children()[0].val() {
                            let sign = sign_token.lexeme();
                            match postfix_node.children()[1].val() {
                                Some(NodeVal::Leaf(val_token)) => {
                                    match val_token.token_type()
                                    {
                                        TokenType::IntegerLit => { eval_stack.push(Immediate(format!("{}{}", sign, val_token.lexeme()))); },
                                        TokenType::FloatLit => { eval_stack.push(ExprParseStorage::Immediate(format!("{}{}", sign, val_token.lexeme().parse::<f32>().unwrap().to_bits().to_string()))); }, //FIXME
                                        _ => panic!()
                                    }
                                }
                                Some(NodeVal::Internal(InternalNodeType::ArithExpr)) => {
                                    eval_stack.push(self.generate_arith_expr_code(
                                        &postfix_node.children()[1],
                                        function_entry,
                                        symbols,
                                    ));
                                }
                                _ => panic!(),
                            }
                        } else {
                            panic!()
                        }
                    }
                    Some(NodeVal::Internal(InternalNodeType::DotOp)) => {
                        eval_stack.push(self.generate_dot_operator_code(
                            postfix_node,
                            function_entry,
                            symbols,
                        ));
                    }
                    Some(NodeVal::Internal(InternalNodeType::TernaryOperation)) => {
                        eval_stack.push(self.generate_ternary_operation_code(
                            postfix_node,
                            function_entry,
                            symbols,
                        ));
                    }
                    Some(NodeVal::Leaf(token)) => {
                        match token.token_type() {
                            TokenType::Id => {
                                if let Some(Scope::Variable(ve)) =
                                    function_entry.table().find_scope_by_ident(token.lexeme())
                                {
                                    let operand: ExprParseStorage = match ve.var_type()
                                    {
                                        Type::Integer
                                        | Type::Float => ExprParseStorage::Labelled(format!("var_{}_{}", function_entry.ident(), ve.ident()), R0),
                                        Type::IntegerArray(_) | Type::FloatArray(_) => {
                                            let idx_res = self.generate_array_indexing_code(ve.var_type(), postfix_node, function_entry, symbols);
                                            match idx_res
                                            {
                                                Register(r) => {
                                                    ExprParseStorage::Labelled(format!("var_{}_{}", function_entry.ident(), ve.ident()), r)
                                                }
                                                _ => panic!()
                                            }
                                        }
                                        Type::String
                                        | Type::StringArray(_)
                                        | Type::Custom(_)
                                        | Type::CustomArray(_, _) => {
                                            unimplemented!(
                                                "Class and string types not implemented."
                                            );
                                        }
                                        _ => panic!(),
                                    };

                                    eval_stack.push(operand);
                                } else if let Some(Scope::FunctionParameter(pe)) =
                                    function_entry.table().find_scope_by_ident(token.lexeme())
                                {
                                    let operand: ExprParseStorage = match pe.param_type()
                                    {
                                        Type::Integer
                                        | Type::Float => ExprParseStorage::Labelled(format!("param_{}_{}", function_entry.ident(), pe.ident()), R0),
                                        Type::IntegerArray(_) | Type::FloatArray(_) => {
                                            let idx_res = self.generate_array_indexing_code(pe.param_type(), postfix_node, function_entry, symbols);
                                            match idx_res
                                            {
                                                Register(r) => {
                                                    ExprParseStorage::Pointer(format!("param_{}_{}", function_entry.ident(), pe.ident()), r)
                                                }
                                                _ => panic!()
                                            }
                                        }
                                        Type::String
                                        | Type::StringArray(_)
                                        | Type::Custom(_)
                                        | Type::CustomArray(_, _) => {
                                            unimplemented!(
                                                "Class and string types not implemented."
                                            );
                                        }
                                        _ => panic!(),
                                    };

                                    eval_stack.push(operand);
                                } else if let Some(Scope::Function(_)) =
                                    symbols.find_scope_by_ident(token.lexeme())
                                {
                                    eval_stack.push(self.generate_function_call_code(
                                        postfix_node,
                                        function_entry,
                                        symbols,
                                    ));
                                } else {
                                    panic!()
                                }
                            }
                            TokenType::IntegerLit => {
                                eval_stack
                                    .push(ExprParseStorage::Immediate(token.lexeme().to_string()));
                            }
                            TokenType::FloatLit => {
                                log::warn!("FLOATING POINTS WILL NOT WORK PROPERLY");
                                eval_stack
                                    .push(ExprParseStorage::Immediate(token.lexeme().parse::<f32>().unwrap().to_bits().to_string())); //FIXME
                            }
                            TokenType::StringLit => {
                                unimplemented!("String operations are not implemented.");
                            }
                            _ => {
                                log::error!("{:?}", token);
                                panic!()
                            }
                        }
                    }
                    _ => panic!(),
                }
            }
        }

        return eval_stack.pop().unwrap();
    }

    fn generate_array_indexing_code(&mut self, var_type: &Type, var_node: &Node, fe: &FunctionEntry, symbols: &SymbolTable) -> ExprParseStorage {
        self.generator.add_comment("`~ Computing array indices ~");
        let idx_reg = self.register_allocator.next_free_register();
        self.generator.add_instruction(Substract(idx_reg, idx_reg, idx_reg));
        match var_type
        {
            Type::IntegerArray(dim)
            | Type::FloatArray(dim) => {
                // step is 4 bytes
                for (idx, indice_node) in var_node.children().iter().enumerate()
                {
                    let col = if idx + 1 >= dim.len() { 1 } else { dim[idx + 1] };
                    match self.generate_arith_expr_code(&indice_node.children()[0], fe, symbols)
                    {
                        Immediate(imm) => {
                            let temp_reg = self.register_allocator.next_free_register();
                            self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                            self.generator.add_instruction(AddImmediate(temp_reg, R0, imm)); // indice
                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, 4)); // sizeof
                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, col as i16)); // col
                            self.generator.add_instruction(Add(idx_reg, idx_reg, temp_reg));
                            self.register_allocator.release_register(temp_reg);
                        }
                        Labelled(label, offs) => {
                            let temp_reg = self.register_allocator.next_free_register();
                            self.generator.add_instruction(LoadWordLabel(temp_reg, offs, label)); // indice
                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, 4)); // sizeof
                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, col as i16)); // col
                            self.generator.add_instruction(Add(idx_reg, idx_reg, temp_reg));
                            self.register_allocator.release_register(offs);
                            self.register_allocator.release_register(temp_reg);
                        }
                        Register(r) => {
                            self.generator.add_instruction(MultiplyImmediate(r, r, 4)); // sizeof
                            self.generator.add_instruction(MultiplyImmediate(r, r, col as i16)); // col
                            self.generator.add_instruction(Add(idx_reg, idx_reg, r));
                            self.register_allocator.release_register(r);
                        }
                        Pointer(label, offs) => {
                            let temp_reg = self.register_allocator.next_free_register();
                            self.generator.add_instruction(Substract(temp_reg, temp_reg, temp_reg));
                            self.generator.add_instruction(LoadWordLabel(temp_reg, R0, label)); // load address
                            self.generator.add_instruction(Add(temp_reg, temp_reg, offs)); // add offset
                            self.generator.add_instruction(LoadWord(temp_reg, temp_reg, 0)); // load actual value at memory location

                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, 4)); // sizeof
                            self.generator.add_instruction(MultiplyImmediate(temp_reg, temp_reg, col as i16)); // col
                            self.generator.add_instruction(Add(idx_reg, idx_reg, temp_reg));

                            self.register_allocator.release_register(offs);
                            self.register_allocator.release_register(temp_reg);
                        }
                    }
                }
            }
            Type::StringArray(_)
            | Type::CustomArray(_, _) => {
                unimplemented!("Class and string array indexing not implemented")
            }
            _ => panic!()
        }

        Register(idx_reg)
    }

    /// When jumping to a function, we store the return address from R15 into the next slot of the fn ptr stack
    fn store_and_inc_fn_ptr(&mut self) {
        self.generator
            .add_instruction(AddImmediate(R14, R14, 4.to_string()));
        self.generator
            .add_instruction(StoreWordLabel(R15, R14, "fn_ptr_stack".to_string()));
    }

    /// When returning from a function, we pop & load the return address of the top of the fn ptr stack into R15 and jump
    fn load_and_dec_fn_ptr(&mut self) {
        self.generator
            .add_instruction(LoadWordLabel(R15, R14, "fn_ptr_stack".to_string()));
        self.generator
            .add_instruction(SubstractImmediate(R14, R14, 4.to_string()));
    }
}

#[derive(Debug)]
pub enum ExprParseStorage {
    /// An immediate value, like an integer or a float
    Immediate(String),
    /// A label, usually for local resources, and an offset
    Labelled(String, Register),
    /// A register
    Register(Register),
    /// Content at label is a memory location
    Pointer(String, Register),
}
